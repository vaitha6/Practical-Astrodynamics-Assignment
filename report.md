# Introduction

Please carefully read the [rules](rules/README.md), they may have changed or been clarified. Refer to the [assignment text](README.md) before doing the tasks described in this document. Don't forget to copy this file to `report.md` and filling your answers there. Do not edit this file.

In the answers below, report the data points with the following the order and units of their components:

- for Cartesian coordinates
    1. time [s]
    2. position x [m]
    3. position y [m]
    4. position z [m]
    5. velocity x [m]
    6. velocity y [m]
    7. velocity z [m]

- for Spherical coordinates:
    1. time [s]
    2. azimuth or longitude [deg] 
    3. elevation or latitude [deg]
    4. radius [m] (not altitude)
    5. azimuthal or latitudinal velocity [deg/s]
    6. elevational or longitudinal velocity [deg/s]
    7. radial velocity [m/s]

- for osculating Keplerian elements
    1. time [s]
    2. semi-major axis [m]
    3. eccentricity []
    4. inclination [deg]
    5. right ascension of the ascending node [deg]
    6. argument of pericenter [deg]
    7. true anomaly [deg]

# 1 Update your orbit

Report the TLE data you retrieved. If you retrieved TLE data in `KVN`, `XML`, `JSON` or `CSV` formats, report it in `TLE` format.

~~~
CRYOSAT 2               
1 36508U 10013A   22328.90580009  .00000192  00000+0  46839-4 0  9990
2 36508  92.0227 322.9868 0006717  71.8601 288.3337 14.51904020669414
~~~

Report the start time of your time domain, in terms of seconds since the epoch of your TLE data.

1000

Report the stop time of your time domain, in terms of seconds since the epoch of your TLE data.

3000

Report the time step in your time domain, in terms of seconds.

1

Report the first data point from the orbit data you generated with the SGP4 propagator.

7.225992610000000000e+08 5.239804788064014167e+06 -3.829793524868291803e+06 -2.887926461450738832e+06 2.278339072428551844e+03 -2.023452206229136664e+03 6.841220702992461156e+03

Report the last data point from the orbit data you generated with the SGP4 propagator.

7.226012600000000000e+08 4.987625449543394148e+06 -3.864465699403453618e+06 3.240341165561934933e+06 -2.897649101450165745e+03 1.868812725970888323e+03 6.660525848641553239e+03

# 2 Implement time system conversions

Report the source code of the function that implements the time system conversions

~~~
    satellite, start_epoch = read_tle(filename)
    #Read TLE data by calling the appropriate function
    
    DUT_file = [i.strip() for i in open('finals2000A.daily').readlines()] 

    J2000=datetime(2000,1,1,12,0,0)
    #J2000 epoch 
    
    UTC = sat_epoch_datetime(satellite)
    UTC_time=UTC 
    #Variable that stores the datetime parameter
    
    UT1=UTC+timedelta(milliseconds=-19.6904)
    UT1_time=UT1
    
    GPS=UTC+timedelta(0,37)
    GPS_time=GPS
    
    UTC_J2000=(UTC.replace(tzinfo=None)-J2000).total_seconds()
    UTC_J2000_time=UTC_J2000+start
    #Start time of domain from the J2000 epoch in UTC
    
    UT1_J2000=(UT1.replace(tzinfo=None)-J2000).total_seconds()
    UT1_J2000_time=UT1_J2000+start
    #Start time of domain from the J2000 epoch in UT1
    
    GPS_J2000=(GPS.replace(tzinfo=None)-J2000).total_seconds()
    GPS_J2000_time=GPS_J2000+start
    #Start time of domain from the J2000 epoch in GPS
~~~

Report the first value of your time domain, in J2000 seconds, when using the UTC standard.

722599261.127776 

Report the first value of your time domain, in J2000 seconds, when using the UT1 standard.

722599261.108086

Report the first value of your time domain, in J2000 seconds, when using the GPS standard.

722599298.127776

For the remaining of the assignment, report the time values as seconds since the J2000 epoch.

# 3 Represent your orbit in terms of Keplerian elements 

Report the source code of the function that implements the Cartesian coordinates to Keplerian elements transformation

~~~
    cart_data=np.loadtxt(filename, dtype=float)
    #Load cartesian co-ordinates

    dim=np.shape(cart_data)
    count=dim[0]
    
    r_0, r_mag, v_mag, h, h_mag, e, e_mag, e_x, e_z, Phi, eta, a, inc, theta, r_dot_e, m1, m2, l1, l2, n1, n2, x, y, z, v_x, v_y, v_z, N_an, N_xy, N_an_mag, Omega, omega, r, r_xy, lambda_1, phi, lambda_0 = declare(count)

    time=cart_data[:,0]
    r=cart_data[:,[1,2,3]]
    v=cart_data[:,[4,5,6]]
    #Assigning cartesian co-ordinates to variables for the purpose of conversion

    for i in range(count):
     
        r_mag[i]=sqrt((r[i,0]**2)+(r[i,1]**2)+(r[i,2]**2))
        v_mag[i]=sqrt((v[i,0]**2)+(v[i,1]**2)+(v[i,2]**2))
        
        h[i,:]=np.cross(r[i,:],v[i,:])
        #Specific angular momentum vector
        
        h_mag[i]=sqrt((h[i,0]**2)+(h[i,1]**2)+(h[i,2]**2))
        
        a[i]=1/((2/r_mag[i])-((v_mag[i]**2)/mu))
        #Semi-major axis
        
        e[i,:]=(np.cross(v[i,:],h[i,:])/mu)-(r[i,:]/r_mag[i])
        #Eccentricity vector
        
        e_x[i,0]=e[i,0]
        e_z[i,2]=e[i,2]
        e_mag[i]=sqrt((e[i,0]**2)+(e[i,1]**2)+(e[i,2]**2))
        
        inc[i]=acos(h[i,2]/h_mag[i])*180/pi
        #Inclination angle
        
        r_dot_e[i]=np.dot((r[i,:]/r_mag[i]),e[i,:]/e_mag[i])
        #Dot product of position and eccentricty vector for calculating true anomaly
        
        if(np.dot((np.cross(e[i,:],r[i,:])),h[i,:])>0):
            sign_theta=1
        else:
            sign_theta=-1
        
        theta[i]=sign_theta*(acos(r_dot_e[i])*180/pi)
        #True anomaly with range of -180 degrees to +180 degrees
        
        N_an[i,:]=np.cross(e_z[i,:],h[i,:])
        #Ascending node vector
        
        N_xy[i]=sqrt((N_an[i,0]**2)+(N_an[i,1]))
        #Ascending node vector projection in the XY plane
        
        N_an_mag[i]=sqrt((N_an[i,0]**2)+(N_an[i,1]**2)+(N_an[i,2]**2))

        Omega[i]=atan2((N_an[i,1]/N_xy[i]),(N_an[i,0]/N_xy[i]))
        #Right ascension
        
        omega[i]=acos(np.dot(N_an[i,:],e[i,:])/(N_an_mag[i]*e_mag[i]))*180/pi
        #Argument of perigee
~~~

Report the first data point of the Keplerian orbit data.

7.225992610000000000e+08 7.100702093429456465e+06 1.373992015554220767e-03 9.202181246227982570e+01 -3.706326243394232733e+01 8.415724767952698926e+01 -1.081605830114289404e+02

Report the last data point of the Keplerian orbit data.

7.226012600000000000e+08 7.099917085861099884e+06 1.986155768580951785e-03 9.202192777734715889e+01 -3.673003735835577999e+01 8.781565800442922409e+01 -6.061406791876117950e+01

Report the markdown code that adds your 6 Keplerian orbit plots to this document.

![alt text](semi_major.png "Semi-major axis vs time" )

![alt text](eccentricity.png "Eccentricity vs time" )

![alt text](inclination_angle.png "Inclination angle vs time" )

![alt text](right_ascension.png "Right Ascension of Ascending Node vs Time" )

![alt text](argument_perigee.png "Argument of perigee vs time" )

![alt text](true_anomaly.png "True anomaly vs time" )

Report the command that you use in the CLI to generate your plots.

python -c "import assignment1_code;assignment1_code.cart_to_kep('out1.dat','kep1.dat')"

Make two observations on the evolution with time of the eccentricity.

~~~
1. The eccentricity varies periodically over time with a frequency that is nearly synchronous with the time period of the satellite.
2. The variation is a combination of two sinusoidal components that individually have different amplitudes.
~~~

Make one interpretation about the observations you reported above.

The variation in eccentricity is caused by more than one perturbation term considered in the propagator.

Make one conclusion based on the observations and interpretations you reported above.

The J2 and J3 terms are likely to have caused the variation in eccentricity.

# 4 Assess the errors of the Cartesian to Keplerian and Keplerian to Cartesian coordinates transformation

Report the source code of the function that implements the Keplerian elements to Cartesian coordinates transformation

~~~
    mod_cart_file=output
    
    kep_data=np.loadtxt(filename, dtype=float)
    #Load keplerian co-ordinates
    
    dim=np.shape(kep_data)
    count=dim[0]
    
    r_0, r_mag, v_mag, h, h_mag, e, e_mag, e_x, e_z, Phi, eta, a, inc, theta, r_dot_e, m1, m2, l1, l2, n1, n2, x, y, z, v_x, v_y, v_z, N_an, N_xy, N_an_mag, Omega, omega, r, r_xy, lambda_1, phi, lambda_0 = declare(count)
    
    time=kep_data[:,0]
    a=kep_data[:,1]
    e_mag=kep_data[:,2]
    inc=kep_data[:,3]*pi/180
    Omega=kep_data[:,4]*pi/180
    omega=kep_data[:,5]*pi/180
    theta=kep_data[:,6]*pi/180
    #Assigning keplerian co-ordinates to individual variables for conversion
    
    for i in range(count):
    
        r_mag[i]=a[i]*(1-e_mag[i]**2)/(1+(e_mag[i]*cos(theta[i])))
        
        phi[i]=r_mag[i]*cos(theta[i])
        #Cosine component of position vector
        
        eta[i]=r_mag[i]*sin(theta[i])
        #Sine component of position vector
    
        l1[i] = cos(Omega[i])*cos(omega[i])-sin(Omega[i])*sin(omega[i])*cos(inc[i])
        l2[i] = -cos(Omega[i])*sin(omega[i])-sin(Omega[i])*cos(omega[i])*cos(inc[i])
        m1[i] = sin(Omega[i])*cos(omega[i])+cos(Omega[i])*sin(omega[i])*cos(inc[i])
        m2[i] = -sin(Omega[i])*sin(omega[i])+cos(Omega[i])*cos(omega[i])*cos(inc[i])
        n1[i] = sin(omega[i])*sin(inc[i])
        n2[i] = cos(omega[i])*sin(inc[i])
        
        rot_mat1=[[l1[i],l2[i]],[m1[i],m2[i]],[n1[i],n2[i]]]
        rot_mat2=[[phi[i]],[eta[i]]]
        #Matrices used for conversion of co-ordinates
        
        [x[i],y[i],z[i]]=np.dot(rot_mat1,rot_mat2)
        #Cartesian position
        
        h_mag[i]=sqrt(mu*a[i]*(1-(e_mag[i]**2)))
        
        rot_mat3=[[-l1[i],l2[i]],[-m1[i],m2[i]],[-n1[i],n2[i]]]
        rot_mat4=[[sin(theta[i])],[e_mag[i]+cos(theta[i])]]
        
        [v_x[i],v_y[i],v_z[i]]=(mu/h_mag[i])*np.dot(rot_mat3,rot_mat4)
        #Cartesian Velocity
        
    out=np.column_stack((time,x,y,z,v_x,v_y,v_z))    
    np.savetxt(output,out)
       
    init_cart_dat1=np.loadtxt(init_cart_file)
    mod_cart_dat1=np.loadtxt(mod_cart_file)
    #Initial and modified cartesian data read for comparison
    
    diff_position=init_cart_dat1[:,[1,2,3]]-mod_cart_dat1[:,[1,2,3]]
    diff_velocity=init_cart_dat1[:,[4,5,6]]-mod_cart_dat1[:,[4,5,6]]
    #Residual error data
~~~

Report the first data point of the back-converted Cartesian orbit data.

7.225992610000000000e+08 5.239804788064013235e+06 -3.829793524868289474e+06 -2.887926461450737435e+06 2.278339072428552299e+03 -2.023452206229136209e+03 6.841220702992463885e+03

Report the last data point of the back-converted Cartesian orbit data.

7.226012600000000000e+08 4.987625449543392286e+06 -3.864465699403452221e+06 3.240341165561936796e+06 -2.897649101450168473e+03 1.868812725970888323e+03 6.660525848641552329e+03

Report the markdown code that adds your 2 residual Cartesian orbit plots to this document.

![alt text](kep_to_cart.png "Residual error for Position and Velocity vs time" )

Report the command that you use in the CLI to generate your plots.

python -c "import assignment1_code;assignment1_code.kep_to_cart('kep1.dat','cart1.dat','out1.dat')"

Make one observations on the residual Cartesian orbit plots.

The mean error is close to zero, however, there are huge spikes in the residual at regular intervals. 

Make one interpretation about the observations you reported above.

The spikes may be caused due to a rounding off error in the solver as they coincide with the points where eccentricity is nearest to zero. Also, there are sudden changes in the true anomaly and argument of perigee at these points which further strengthens the argument.

Make one conclusion based on the observations and interpretations you reported above.

The conversion of co-ordinates is mostly correct with the exemption of the regions with sudden spikes.

# 5 Represent your orbit in terms of (inertial) Spherical coordinates

Report the source code of the function that implements the Cartesian to Spherical coordinates transformation

~~~
    cart_data=np.loadtxt(filename, dtype=float)
    #Load cartesian co-ordinates
    
    dim=np.shape(cart_data)
    count=dim[0]
    
    r_0, r_mag, v_mag, h, h_mag, e, e_mag, e_x, e_z, Phi, eta, a, inc, theta, r_dot_e, m1, m2, l1, l2, n1, n2, x, y, z, v_x, v_y, v_z, N_an, N_xy, N_an_mag, Omega, omega, r, r_xy, lambda_1, phi, lambda_0 = declare(count)

    time=cart_data[:,0]
    x=cart_data[:,1]
    y=cart_data[:,2]
    z=cart_data[:,3]
    #Assigning cartesian co-ordinates to individual variables for conversion
    
    R_p = (f-1)*R_e
    #Polar radius in terms of oblateness
    
    for i in range(count):
    
        r[i]=sqrt((x[i]**2)+(y[i]**2)+(z[i]**2))
        r_xy[i]=sqrt((x[i]**2)+(y[i]**2))
        
        lambda_1[i]=atan2((y[i]/r_xy[i]),(x[i]/r_xy[i]))*180/pi
        
        Phi[i]=asin(z[i]/r[i])*180/pi
        
        deno = (np.cos(lambda_1[i])**2)/R_e**2 + (np.sin(lambda_1[i])**2)/R_p**2
        r_0[i] = np.sqrt(1/deno)
        #Radius of Earth as a function of latitude
   ~~~

Report the first data point of the Spherical orbit position.

7.225992610000000000e+08 -3.616321337348744436e+01 -2.398745321382779494e+01 7.103730844203561544e+06

Report the last data point of the Spherical orbit position.

7.226012600000000000e+08 -3.776890848320706340e+01 2.718325716521293600e+01 7.092976359472379088e+06

Report the markdown code that adds your 3 Spherical orbit plots to this document.

![alt text](latandlon_vs_time.png "Lattitude and Longitude vs Time" )

![alt text](lat_vs_lon_inertial.png "Latitude vs Longitude for Inertial frame" )

![alt text](alt_vs_time.png "Altitude vs Time" ) 

Report the command that you use in the CLI to generate your plots.

python -c "import assignment1_code;assignment1_code.cart_to_spher('out1.dat','spher1.dat')"

Make three observations on the difference between the lines plotted in step 2.ii of this task, showing the altitude considering a spherical and oblate Earth.

~~~
1. The altitude variation for a spherical Earth is purely sinusoidal with a constant amplitude and frequency.
2. The altitude variation for an oblate Earth varies abruptly over short periods of time, however, the average value seems to vary sinusoidally with two individual components over the entire time domain.
3. The amplitude of the altitude variation for the oblate Earth is around twice that for the spherical Earth and is equal to around 20km.
~~~

Make two interpretations about the observations you reported above.

~~~
1. The sinusoidal variation of the altitude for a spherical Earth is likely due to the geometry or eccentricity of the orbit.
2. The variation of altitude for the oblate Earth matches the difference in polar and equitorial radius of the Earth, implying that the satellite traverses close to both the pole and the equator.
~~~

Make one conclusion based on the observations and interpretations you reported above.

The orbit of the satellite is likely to be a polar orbit.

# 6 Assess the errors of the Cartesian to Spherical and Spherical to Cartesian coordinates transformation

Report the source code of the function that implements the Spherical to Cartesian coordinates transformation

~~~
    cart_data=np.loadtxt(filename, dtype=float)
    #Load spherical co-ordinates

    mod_cart_file=output
    
    dim=np.shape(cart_data)
    count=dim[0]
    
    r_0, r_mag, v_mag, h, h_mag, e, e_mag, e_x, e_z, Phi, eta, a, inc, theta, r_dot_e, m1, m2, l1, l2, n1, n2, x, y, z, v_x, v_y, v_z, N_an, N_xy, N_an_mag, Omega, omega, r, r_xy, lambda_1, phi, lambda_0 = declare(count)
    
    time=cart_data[:,0]
    
    lambda_1=cart_data[:,1]*pi/180
    phi=cart_data[:,2]*pi/180
    r=cart_data[:,3]
    #Assigning spherical co-ordinates to individual variables for conversion
    
    for i in range(count):
        
        x[i]=r[i]*cos(phi[i])*cos(lambda_1[i])
        y[i]=r[i]*cos(phi[i])*sin(lambda_1[i])
        z[i]=r[i]*sin(phi[i])
            
    out=np.column_stack((time,x,y,z))    
    np.savetxt(output,out)
    
    init_cart_dat1=np.loadtxt(init_cart_file)
    mod_cart_dat2=np.loadtxt(mod_cart_file)
    #Storing initial and modified cartesian co-ordinates in separate variables for comparison
    
    diff_position=mod_cart_dat2[:,[1,2,3]]-init_cart_dat1[:,[1,2,3]]
~~~

Report the first data point of the back-converted Cartesian orbit position.

7.225992610000000000e+08 5.239804788064014167e+06 -3.829793524868291803e+06 -2.887926461450738832e+06

Report the last data point of the back-converted Cartesian orbit position.

7.226012600000000000e+08 4.987625449543393217e+06 -3.864465699403452687e+06 3.240341165561934933e+06

Report the markdown code that adds your 2 residual Cartesian orbit plots to this document.

![alt text](residual_plot_spher.png "Residual Error for position vs time" ) 

Report the command that you use in the CLI to generate your plots.

python -c "import assignment1_code;assignment1_code.spher_to_cart('spher1.dat','cart2.dat','out1.dat')"

Make two observations on the difference between residual Cartesian orbit plots of this task and those of Task 4 (positions only).

~~~
1. The residual plots for this task do not have spikes as large as for the one in task 4.
2. The error values for this task are in the range of 1E-8
~~~

Make one interpretations about the observations you reported above.

The difference between the initial and back-converted cartesian co-ordinates for this task is negligible throughout the time domain, unlike for task 4. This implies that the conversion between cartesian and spherical co-ordinates is correct and accurate.

Make one conclusion based on the observations and interpretations you reported above.

The spikes obtained in task 4 are likely due to a logical, coding or rounding-off error and may not represent the actual dynamics of the orbit.

# 7 Represent your orbit in terms of co-rotating Spherical coordinates

Report the source code of the function that implements the inertial to co-rotating Spherical coordinates transformation (positions only).

~~~
    spher_data=np.loadtxt(filename, dtype=float)
    #Load inertial spherical co-ordinates
    
    dim=np.shape(spher_data)
    count=dim[0]
    
    r_0, r_mag, v_mag, h, h_mag, e, e_mag, e_x, e_z, Phi, eta, a, inc, theta, r_dot_e, m1, m2, l1, l2, n1, n2, x, y, z, v_x, v_y, v_z, N_an, N_xy, N_an_mag, Omega, omega, r, r_xy, lambda_1, phi, lambda_0 = declare(count)

    time=spher_data[:,0]
    step=time[1]-time[0]
    
    lambda_1=spher_data[:,1]*pi/180
    phi=spher_data[:,2]*pi/180
    r=spher_data[:,3]

    phi_AE=51.98988681616558
    lambda_AE=4.375752354503242
    #Location of Aerospace Faculty
     
    x_AE=R_e*cos(phi_AE)*cos(lambda_AE)
    y_AE=R_e*cos(phi_AE)*sin(lambda_AE)
    z_AE=R_e*sin(phi_AE)
    
    r_AE=sqrt((x_AE**2)+(y_AE**2)+(z_AE**2))
    #Cartesian co-ordinates of Aerospace Faculty to determine closest approach
    
    nearest_r=1e+10
    #Default large initial value 
    
    for i in range(count):
        
        lambda_0[i]=lambda_1[i]-(omega_e*step)
        
        temp=r[i]-r_AE
        #Temporary variable for distance between satellite and Faculty
        
        if(temp<nearest_r):

            nearest_r=temp
            near_time=time[i]
            near_time_MJD=((near_time-0.0196904)/864000)+2459907.5-2400000.5
        #To check if current distance between satellite and Faculty is the shortest
~~~

Report the first value for the longitude of the Co-rotating orbit.

-6.312400626186017716e-01

Report the last value for the longitude of the Co-rotating orbit.

-6.592647290663807835e-01

Report the markdown code that adds your Co-rotating orbit plot to this document.

![alt text](lat_vs_lon_co.png "Latitude vs longitude for co-rotating frame" ) 

Report the command that you use in the CLI to generate your plot.

python -c "import assignment1_code;assignment1_code.co_rotating_spher('spher1.dat','co.dat')"

Determine the time of closest approach of your satellite to the Aerospace Faculty (latitude 51.98988681616558, longitude 4.375752354503242), in the UT1 time standard using the Modified Julian Date representation.

60743.341771968175

### 6 Final remarks

Report the steps you have taken to address Code Excellence. Report "none" if relevant.

~~~
1. Used CLI commands to execute the relevant scripts. 
2. Created a single script with functions for all the given tasks.
3. Unit testing was performed by running each function in a separate script to view the variation of the intermediate variables that helped in correcting any code errors.
~~~

Report the steps you have taken to address Assignment Excellence. Report "none" if relevant.

- have your code automatically download the leap-second and time correction tables.

None

- share your routines that read the leap-second and time correction tables in a public GitLab repository.

None

- use `stdin` to read the orbit data and `stdout` to write the converted orbit data in your conversion program; use `stdin` to read the converted orbit data in your plotting program; pipe the two programs together.

None

- plot the geographic outline of the continents in the plot of Task 7.

None

Report how long it took you to solve this assignment, in (fractional) hours.

16.5 

Please provide any feedback on the assignment, for example, how it felt to work through it, if you found it to be too easy or difficult or if you learned new things or skills.

Interesting assignment, however it was quite long. 
